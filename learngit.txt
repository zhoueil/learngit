
Git 分布式版本控制系统

1. Git 的使用方法
	1. 创建一个文件夹   mkdir learngit
	
	2. 通过 git init 命令把这个目录Git可以管理的仓库;   
	
	3. 在这个目录下创建一个文件;  1)  用命令 git add 告诉Git,把文件添加到仓库; eg: git  add readme.txt
			               2)  用命令 git commit  告诉Git ,把文件提交到仓库;  git commit  -m  " msg "
	    提交成功之后   1. file  changed :  1个文件被改动(我们新添加的readme.txt文件)
		           2. insertions :  插入了两行内容(readme.txt有两行内容.)

	为什么Git 添加文件需要add ,commit一共两步呢? 
	     因为commit 可以一次提交很多文件,所以你可以多次 add不同的文件,比如:
		git add file1.txt
		git add file2.txt file3.txt
		git commit -m "add 3 files."
	
	4. 查看具体修改的内容: git diff     (顾名思义 就是查看difference )
		eg: git diff readme.txt

	5.提交修改和提交新文件是一样的两步,

	6.git status 查看当前git 的状态

	7. 在Git中,我们用 git log 命令查看历史记录

	8.将当前版本回退到上一个版本 ,就可以使用 git reset 命令:  eg:  git reset --hard HEAD^

	9. 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，
  	    再想恢复到append GPL，就必须找到append GPL的commit id。
                    Git提供了一个命令git reflog用来记录你的每一次命令;
	  
 	 回去: git reset --hard  [commonId]
	HEAD 指向的版本就是当前版本,因此,Git 允许我们在版本的历史之间穿梭,使用命令 git reset --hard  commit_ id.
	穿梭前,用git log 可以查看提交历史,以便确定要回退哪个版本.
  	要重返未来,用 git reflog 查看命令历史,以便确定要回到未来的哪个版本.

	10. 命令 git checkout  --readme.txt  意思就是,把 readme.txt 文件在工作区的修改全部撤销, 这里又两种情况:
	     一种是 readme.txt 自修改后还没有被存放到暂存区,现在,撤销 修改就回到和版本库一模一样的状态;
	     一种是readme.txt 已经添加到暂存区后,又做了修改,现在,撤销修改就回到添加缓存区后的状态.
	     总之, 就是让这个文件回到最近一次git commit 或 git add时的状态.

	    场景1:  当你改乱了工作区某个文件的内容,想直接丢到工作区的修改时候, 用命令, git checkout -- file.
	    场景2:  当你不但该乱了工作区某个文件的内容 ,  还添加到了暂存区时,想丢弃修改,分两步,第一步用命令
		git reset  HEAD<file>  , 就回到了场景1, 第二步按场景1操作.
	    场景3: 已经提交了不合适的修改到版本库时,想要撤销本次提交. 参考版本回退.

	11. 一般情况下,你通常直接在文件管理器中把没有的文件删了,或者用rm命令删了;
	     eg:   rm test.txt
	     现在有两个选择,一是确实要从版本库中删除该文件, 那就用命令 git rm 删掉,并且git commit;
	    eg:  git rm test.txt  
 	          git commit  -m  "remove  test.txt"
	     另一种情况是删错了, 因为版本库里还呢,所以可以很轻松地把误删的文件恢复到最新版本:
	    eg: git checkout -- test.txt
	      git checkout 其实是用版本库里的版本替换工作区的版本, 无论工作区是修改还是删除, 都可以 "一键还原".

   	   命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，
	    你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。

	12.将本地关联到远程库中去:
	     git remote add origin git@github.com:zhoueil/learngit.git
	  
	把本地库的内容推送到远程, 用git push命令,实际上把当前分支 master 推送到远程.
	eg: git push -u origin master
	 (由于远程库是空的,我们第一次推送master分支时,加上-u 参数,Git不但会把本地的master 分支内容推送的远程新的master
	  分支,还会把本地的master 分支和远程的master 分支关联起来,在以后的推送或者拉取时就可以简化命令.)

2. 版本库(Repository)
	工作区有一个隐藏目录 .git, 这个不算工作区,而是Git 的版本库.
	
	Git的版本库里存了很多东西 ,其中最重要的就是称为stage (或者叫index) 的暂存区, 还有Git 为我们自动创建的第一个分支
	master, 以及指向 master 的一个指针叫做HEAD.

     过程:   工作区 (add) -->   stage(commit) --> master(指针HEAD 指向master)
	第一步:  是用   git  add  把文件添加进去,实际上就是把文件修改添加到暂存区;
	第二步:  是用   git  commit 提交更改,实际上就是把暂存区的所有内容提交到当前分支
	     1)可以简单的理解为,需要提交的文件修改通通放到暂存区,然后,一次性提交暂存区的所有修改.
	     2)git add 命令实际上就是把要提交的所有修改放到暂存区,然后,执行 git commit 就可以一次性把暂存区的
	        所有修改提交到分支.
	     3) 一旦提交后,如果你又没有对工作区做任何修改,那么工作区就是 "干净" 的;
	     Git 管理的是修改,当你用 git add命令后,在工作区的第一次修改被放入暂存区,准备提交,但是,在工作
	     区的第二次修改并没有放入暂存区,所以,git commit 只负责把暂存区的修改提交了,也就是第一次的修改被提交了,第二次的
	     修改不会被提交.
	     4) 第一次修改 --> git add  --> 第二次修改 --> git add --> git commit 
	         每次修改,如果不用 git add 到暂存区, 那就不会加入到commit 中.

	     

		
		
	 


  	     